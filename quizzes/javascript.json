[
    {
        "answers": [
            {
                "score": 1,
                "value": "NaN === NaN returns true",
                "explanation": "This is the right answer. To check if a number is NaN, use the isNaN function."
            },
            {
                "score": 0,
                "value": "undefined === undefined returns true",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "typeof null returns object",
                "explanation": "This answer is wrong. null is an object."
            },
            {
                "score": 0,
                "value": "typeof undefined returns undefined",
                "explanation": "This answer is wrong. undefined is a special type named undefined."
            }
        ],
        "question": "Which of the following is false?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "num.toFixed(1)",
                "explanation": "This is the right answer."
            },
            {
                "score": 0,
                "value": "Math.round(num, 1)",
                "explanation": "This answer is wrong. The round function does not have a second argument."
            },
            {
                "score": 0,
                "value": "new Intl.NumberFormat('en-US', { minimumFractionDigits: 1 }).format(num)",
                "explanation": "This answer is wrong. The right option is maximumFractionDigits."
            },
            {
                "score": 0,
                "value": "Math.floor(num * 10) / 10",
                "explanation": "This answer is wrong. Use Math.round instead of Math.floor."
            }
        ],
        "question": "How do you round a decimal (num) upto one decimal place?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "arr.splice(index, 1)",
                "explanation": "This is the right answer."
            },
            {
                "score": 0,
                "value": "arr.remove(index)",
                "explanation": "This answer is wrong. There is no remove function."
            },
            {
                "score": 0,
                "value": "arr.pop(index)",
                "explanation": "This answer is wrong. The pop function removes only the last item."
            },
            {
                "score": 0,
                "value": "arr.shift(index)",
                "explanation": "This answer is wrong. The shift function removes only the first item."
            }
        ],
        "question": "How do you remove an item at a specified position (index) from an array (arr)?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "Use the map function.",
                "explanation": "This is the right answer. map function returns a new array."
            },
            {
                "score": 0,
                "value": "Use the find function.",
                "explanation": "This answer is wrong. Check if find returns a non-null value."
            },
            {
                "score": 0,
                "value": "Use the findIndex function.",
                "explanation": "This answer is wrong. Check if findIndex returns an index greater than -1."
            },
            {
                "score": 0,
                "value": "Use the some function.",
                "explanation": "This answer is wrong. Check if some function returns true."
            }
        ],
        "question": "Which of the following is NOT a way to check if an item exists in an array?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "It does NOT have its own this binding.",
                "explanation": "This is the right answer. Arrow functions retain the this value from the enclosing scope."
            },
            {
                "score": 0,
                "value": "It can be used as a constructor.",
                "explanation": "This answer is wrong. It is not possible to call it using new keyword."
            },
            {
                "score": 0,
                "value": "Using bind, it is possible to reassign this.",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "It has an arguments array.",
                "explanation": "This answer is wrong. It does not have an arguments."
            }
        ],
        "question": "Which of the following about arrow functions is true?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "It stores props.params.timestamp into a new constant named timestamp",
                "explanation": "This is the right answer."
            },
            {
                "score": 0,
                "value": "It stores props.timestamp into a new constant named params",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "It stores props.params.timestamp and props.params into two new constants named timestamp and params respectively",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "It stores props.params into a new constant named timestamp",
                "explanation": "This answer is wrong."
            }
        ],
        "question": "What does 'const { params: { timestamp } } = props' do?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "2",
                "explanation": "This is the right answer. || operator returns 1. && operator returns 2."
            },
            {
                "score": 0,
                "value": "true",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "0",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "1",
                "explanation": "This answer is wrong."
            }
        ],
        "question": "const x = 0 || 1 && 2; What is the value of x?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "function",
                "explanation": "This is the right answer. class is a syntactical sugar for functions."
            },
            {
                "score": 0,
                "value": "func",
                "explanation": "This answer is wrong. There is no such type."
            },
            {
                "score": 0,
                "value": "object",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "undefined",
                "explanation": "This answer is wrong."
            }
        ],
        "question": "class A {}; What is the typeof A?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "1005, 95",
                "explanation": "This is the right answer. + operator concatenates the two as string. - operator converts the two to numbers."
            },
            {
                "score": 0,
                "value": "NaN, NaN",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "105, 95",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "1005, NaN",
                "explanation": "This answer is wrong."
            }
        ],
        "question": "const x = '100' + '5'; const y = '100' - '5'; What is the value of x and y?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "({ a, b } = { a: 1, b: 2 });",
                "explanation": "This is the right answer. Destructuring to an existing variable requires a parenthesis around the expression."
            },
            {
                "score": 0,
                "value": "{ a, b } = { a: 1, b: 2 };",
                "explanation": "This answer is wrong. Without parenthesis, the left side is considered a code block."
            },
            {
                "score": 0,
                "value": "let { a, b } = { a: 1, b: 2 };",
                "explanation": "This answer is wrong. a, b are new variables declared."
            },
            {
                "score": 0,
                "value": "It is not possible to destructure into already defined variables.",
                "explanation": "This answer is wrong."
            }
        ],
        "question": "Which of the following is the right syntax for destructuring into already defined variables?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "This helps to call the function without any argument.",
                "explanation": "This is the right answer."
            },
            {
                "score": 0,
                "value": "This syntax is not valid.",
                "explanation": "This answer is wrong. "
            },
            {
                "score": 0,
                "value": "Destructuring into empty object is redundant syntax and has no useful purpose.",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "This helps to avoid lint errors.",
                "explanation": "This answer is wrong."
            }
        ],
        "question": "function p({ a = 5, b = 7 } = {}) {}; Why do we need to destructure into any empty object?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "const { theProp, ...rest } = obj;",
                "explanation": "This is the right answer. The rest object has all properties except theProp."
            },
            {
                "score": 0,
                "value": "delete obj.theProp;",
                "explanation": "This answer is wrong. This mutates obj."
            },
            {
                "score": 0,
                "value": "obj.theProp = undefined;",
                "explanation": "This answer is wrong. This mutates obj and does not remove the property."
            },
            {
                "score": 0,
                "value": "const rest = { ...obj, theProp: undefined }",
                "explanation": "This answer is wrong. Though it works, this is not the preferred way."
            }
        ],
        "question": "What is the right syntax for dropping a property (theProp) from an object without mutating the object?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "20, 10",
                "explanation": "This is the right answer. a has the second value in the array. b has the default value."
            },
            {
                "score": 0,
                "value": "10, 20",
                "explanation": "This answer is wrong. Using the comma omits the first value in the array"
            },
            {
                "score": 0,
                "value": "There is a SyntaxError",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "20, undefined",
                "explanation": "This answer is wrong. b has a default value set."
            }
        ],
        "question": "const [, a, b = 10] = [10, 20]; What is the value of a, b?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "John",
                "explanation": "This is the right answer. Proxy should override the get method."
            },
            {
                "score": 0,
                "value": "Doe",
                "explanation": "This answer is wrong. The handler for proxy cannot have arbitrary properties."
            },
            {
                "score": 0,
                "value": "There is a SyntaxError",
                "explanation": "This answer is wrong. Though the handler has invalid properties, it still works."
            },
            {
                "score": 0,
                "value": "undefined",
                "explanation": "This answer is wrong. There is no get method to override name."
            }
        ],
        "question": "const obj = { name: 'John' }; const proxy = new Proxy(obj, { name: 'Doe' }); What is the value of proxy.name?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "[2, 3], [1, 5, 4]",
                "explanation": "This is the right answer. Splice mutates the array and returns the deleted items."
            },
            {
                "score": 0,
                "value": "[1, 5, 4], [1, 2, 3, 4]",
                "explanation": "This answer is wrong. This answer assumes that the original array is not mutated."
            },
            {
                "score": 0,
                "value": "[2, 3], [1, 4, 5]",
                "explanation": "This answer is wrong. This answer inserts 5 at the end of the array and not at index = 1."
            },
            {
                "score": 0,
                "value": "[1, 2], [5, 3, 4]",
                "explanation": "This answer is wrong. This answer assumes that array index starts with 1 and not 0."
            }
        ],
        "question": "const arr = [1, 2, 3, 4]; const result = arr.splice(1, 2, 5); What is the value of result and arr?"
    },
    {
        "answers": [
            {
                "score": 1,
                "value": "funcB is called.",
                "explanation": "This is the right answer. If there is a rejected promise, the control will move immediately to catch block."
            },
            {
                "score": 0,
                "value": "funcA is called",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "Both funcA and funcB is called.",
                "explanation": "This answer is wrong."
            },
            {
                "score": 0,
                "value": "There is a Syntax Error",
                "explanation": "This answer is wrong."
            }
        ],
        "question": "Promise.all(42, Promise.reject(42)).then(funcA).catch(funcB); Which of the following is true?"
    }
]